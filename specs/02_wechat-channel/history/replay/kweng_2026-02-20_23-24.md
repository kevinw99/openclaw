# Spec 02: wechat-channel - Session Replay

## Session: 2026-02-20T23:24 ~ 2026-02-21T00:21
> Person: kweng | Messages: 244 | Turns: 5

---

### 23:24 - ide

**Prompt:**
> ide

**Result:**
*(no text response — tools only)*

---

### 23:25 - "Steps to Disable SIP

**Prompt:**
> "Steps to Disable SIP
> 1. Click  (top-left) → Shut Down
> 2. After Mac shuts down, press and hold the power button (~10 sec)
>    → Screen shows "Loading startup options..."
> 3. Click "Options" → "Continue"

<details>
<summary>Full prompt (506 chars)</summary>

"Steps to Disable SIP
1. Click  (top-left) → Shut Down
2. After Mac shuts down, press and hold the power button (~10 sec)
   → Screen shows "Loading startup options..."
3. Click "Options" → "Continue"
   (May ask for your password)
4. Top menu bar → Utilities → Terminal
5. Type: csrutil disable
   Press Enter (confirm if prompted)
6. Type: reboot
After reboot, come back here and I'll run the key extraction script.

" I 've done the part to disable SIP, please continue to run the key extraction script.

</details>

**Result:**
The script is ready. Here's what to do:

**Step 1: Quit WeChat** (so we can capture the key at startup)
- Right-click the WeChat dock icon → Quit, or `Cmd+Q`

**Step 2: Once WeChat is quit, tell me** and I'll run the extraction script. It will:
1. Launch WeChat under LLDB with a breakpoint on `sqlite3_key`
2. You log in to WeChat when the window appears
3. The key gets captured automatically and saved to `~/.wechat_db_key`

Have you quit WeChat?

*Tools: Bash (3), Glob (2), Grep (1), Read (3), Write (1) -- /Users/kweng/AI/openclaw/scripts/extract_wechat_key.py, /Users/kweng/AI/openclaw/spec/03_personal-knowledge-extraction/status.md, /Users/kweng/AI/openclaw/spec/03_personal-knowledge-extraction/tasks.md, /Users/kweng/AI/openclaw/src/knowledge_harvester/adapters/wechat.py, pattern:**/*extract*key* +2 more -- Check CPU architecture (Intel vs Apple Silicon); Check if WeChat is running; Check SIP status*

---

### 23:37 - yes I have quitted

**Prompt:**
> yes I have quitted

**Result:**
Good, WeChat is stopped. Running the extraction script now. **When WeChat opens, log in to your account** — the key will be captured automatically.

Syntax error from nested triple-quotes. Let me fix that.

Now running the extraction. **Log in to WeChat when it opens.**

The Python callback approach didn't work with LLDB. Let me use a simpler, direct LLDB approach with inline commands.

Let me rewrite the script with a much simpler approach — using LLDB's built-in `memory read` command instead of a Python callback.

The issue is LLDB can't pause the WeChat process — likely a Hardened Runtime restriction. Even with SIP disabled, we may need `sudo` or to strip code signing. Let me try a different approach.

WeChat has Hardened Runtime enabled (`flags=0x10000(runtime)`). Even with SIP disabled, we need `sudo` to debug it. Let me try a different approach — launch WeChat normally, then attach with `sudo lldb`.

Let me first enable developer tools security (allows debugging) and then try the approach.

I can't use `sudo` from this terminal. Let me try a no-sudo approach — copy WeChat and strip its Hardened Runtime signature so LLDB can debug it.

Good — you own the WeChat binary. I can re-sign it to add a debug entitlement (allows LLDB to attach). Let me first back up the original, then re-sign.

Now let me create entitlements with the debug flag and re-sign WeChat.

Hardened Runtime is now removed (flags changed from `0x10000(runtime)` to `0x2(adhoc)`). Now LLDB should be able to debug WeChat. Let me make sure WeChat is stopped and run the extraction.

LLDB is running and WeChat should be launching. Let me check the output — **if WeChat opens, please log in to trigger the database access**.

WeChat launched successfully under LLDB but the breakpoint hasn't fired yet. WeChat might be using its own WCDB library instead of system SQLite. Let me check while WeChat is still running.

No bundled WCDB/SQLite library — WeChat uses the system one. But the breakpoint hasn't fired. Let me check if SQLite functions are statically linked into the WeChat binary itself.

Found it — WCDB/SQLCipher is **statically linked** into the WeChat binary (not using system SQLite). That's why the breakpoint on `libsqlite3.dylib` never fired. Let me find the right symbol.

The binary is stripped — no `sqlite3_key` symbol visible. But I see it imports `CCKeyDerivationPBKDF` (the PBKDF2 key derivation function that SQLCipher calls with the raw key). Let me use that as the breakpoint instead.

First, let me stop the current LLDB session and check for WCDB Objective-C methods too.

That "Network disconnected" is because the ad-hoc re-signing broke WeChat's sandbox network permissions. The `dnssd` errors in the LLDB log confirmed this.

Let me restore the original WeChat binary first, then take a different approach.

Good, original WeChat restored (Hardened Runtime back). Now let me check if the DB files are actually encrypted — if not, we don't need the key at all.

The DB is encrypted (no SQLite header — just random bytes). We need the key. The re-signing broke network access. Let me check the full original entitlements — I might have missed the network ones.

Found it — I was missing `com.apple.security.network.client` and `com.apple.security.network.server` in my re-signing. Let me re-sign with ALL original entitlements plus the debug flag.

Good — Hardened Runtime removed, all original entitlements preserved plus `get-task-allow`. Now let me set up the LLDB command file with the right breakpoint. Since WCDB is statically linked, I'll target `CCKeyDerivationPBKDF` in libcommonCrypto (SQLCipher calls this with the raw key).

**Key captured!** The `CCKeyDerivationPBKDF` breakpoint fired and I got the memory dump. Let me extract and save the key.

Now let me restore the original WeChat binary and verify the key works on the database.

Good, original WeChat is restored with Hardened Runtime. Now let me verify the key by trying to decrypt the database.

Key didn't work with v3 mode. Let me try different WCDB cipher configurations.

None worked. The key from `CCKeyDerivationPBKDF` might not be the WCDB key (it fires for many things). Let me investigate the database structure more and try WCDB-specific settings.

All DBs are encrypted. The key from `CCKeyDerivationPBKDF` was likely from something else (TLS etc.). Let me find the actual WCDB Objective-C methods to get the right key.

The first `CCKeyDerivationPBKDF` call was probably from TLS, not WCDB. I need to capture ALL calls and find the one with SQLCipher-specific parameters (256,000 or 64,000 rounds). Let me re-run with a smarter breakpoint.

Now let me write a more sophisticated LLDB script that captures all `CCKeyDerivationPBKDF` calls, logs the parameters, and writes them to a file.

The `-F` flag needs the module-qualified name. Let me fix this.

*Tools: Bash (64), Edit (2), Read (1), TaskStop (1), Write (8) -- /Users/kweng/AI/openclaw/scripts/extract_wechat_key.py, /Users/kweng/AI/openclaw/scripts/extract_wechat_key.sh, /tmp/extract_key.lldb, /tmp/extract_key2.lldb, /tmp/extract_key3.lldb +3 more -- Verify WeChat is not running; Run LLDB-based WeChat key extraction; Verify script syntax is valid*

---

### 00:21 - can you create a agents team for this to speed up?

**Prompt:**
> can you create a agents team for this to speed up?

**Result:**
*(no text response — tools only)*

---

### 00:21 - [Request interrupted by user]

**Prompt:**
> [Request interrupted by user]

**Result:**
*(no text response — tools only)*

---
